import fs from 'node:fs/promises';
import path from 'node:path';

import { Cache } from '@d-zero/shared/cache';
import { imageSize } from 'image-size';

/**
 * Options for automatic image size addition
 */
export interface ImageSizesOptions {
	/**
	 * Root directory for image files
	 */
	readonly rootDir?: string;
	/**
	 * Selector for target image elements
	 */
	readonly selector?: string;
	/**
	 * List of image extensions to target
	 * @default ['png', 'jpg', 'jpeg', 'webp', 'avif', 'svg']
	 */
	readonly ext?: readonly string[];
}

type ImageSize = {
	readonly width: number;
	readonly height: number;
};

/**
 * Asynchronously retrieves the dimensions of an image file.
 * @param filePath - The path to the image file to measure
 * @returns A Promise that resolves to an ImageSize object containing the dimensions of the image
 * @throws {Error} Will throw an error if the file cannot be read or if the image format is not supported
 */
async function sizeOf(filePath: string): Promise<ImageSize> {
	const buffer = await fs.readFile(filePath);
	const res = imageSize(buffer);
	return res;
}

/**
 * Automatically adds width/height attributes to image elements
 * @param elements - Array of DOM elements
 * @param options - Options for adding image sizes
 * @param options.rootDir - Root directory for image files
 * @param options.selector - Selector for target image elements
 * @param options.ext - List of image extensions to target (default: ['png', 'jpg', 'jpeg', 'webp', 'avif', 'svg'])
 */
export async function imageSizes(
	elements: Element[],
	{
		rootDir,
		selector,
		// https://github.com/image-size/image-size?tab=readme-ov-file#supported-formats
		ext = ['png', 'jpg', 'jpeg', 'webp', 'avif', 'svg'],
	}: ImageSizesOptions,
) {
	const cache = new Cache<ImageSize>('@d-zero/builder/image-sizes');

	const images = elements.flatMap((el) => [
		...el.querySelectorAll('img, picture > source'),
	]);

	for (const img of images) {
		if (selector && !img.matches(selector)) {
			continue;
		}

		const src = img.getAttribute('src');

		if (
			!src ||
			src.startsWith('data://') ||
			src.startsWith('http://') ||
			src.startsWith('https://') ||
			src.startsWith('//') ||
			!ext.some((e) => src.endsWith(`.${e}`))
		) {
			continue;
		}

		const filePath = path.join(rootDir ?? '', ...src.split('/'));
		const stats = await fs.stat(filePath).catch(() => null);

		if (!stats) {
			continue;
		}

		const size = stats.size;

		const cacheKey = `${src}:${size}`;

		const cached = await cache.load(cacheKey);

		if (cached) {
			// Update the DOM
			img.setAttribute('width', `${cached.width}`);
			img.setAttribute('height', `${cached.height}`);
			continue;
		}

		const imageSize = await sizeOf(filePath);

		if (!imageSize || !(imageSize.width && imageSize.height)) {
			continue;
		}

		img.setAttribute('width', `${imageSize.width}`);
		img.setAttribute('height', `${imageSize.height}`);

		await cache.store(cacheKey, imageSize);
	}
}
